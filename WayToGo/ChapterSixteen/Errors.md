# 常见的陷阱与错误
* 永远不要使用形如 var p*a 声明变量，这会混淆指针声明和乘法运算（参考4.9小节）
* 永远不要在for循环自身中改变计数器变量（参考5.4小节）
* 永远不要在for-range循环中使用一个值去改变自身的值（参考5.4.4小节）
* 永远不要将goto和前置标签一起使用（参考5.6小节）
* 永远不要忘记在函数名（参考第6章）后加括号()，尤其调用一个对象的方法或者使用匿名函数启动一个协程时
* 永远不要使用new()一个map，一直使用make（参考第8章）
* 当为一个类型定义一个String()方法时，不要使用fmt.Print或者类似的代码（参考10.7小节）
* 永远不要忘记当终止缓存写入时，使用Flush函数（参考12.2.3小节）
* 永远不要忽略错误提示，忽略错误会导致程序奔溃（参考13.1小节）
* 不要使用全局变量或者共享内存，这会使并发执行的代码变得不安全（参考14.1小节）
* println函数仅仅是用于调试的目的

* 使用正确的方式初始化一个元素是切片的映射，例如map[type]slice（参考8.1.3小节）
* 一直使用逗号，ok或者checked形式作为类型断言（参考11.3小节）
* 使用一个工厂函数创建并初始化自己定义类型（参考10.2小节-18.4小节）
* 仅当一个结构体的方法想改变结构体时，使用结构体指针作为方法的接受者，否则使用一个结构体值类型10.6.3小节

# 误用短声明导致变量覆盖

# 误用字符串
* 应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中
```
var b bytes.Buffer
...
for condition {
    b.WriteString(str) // 将字符串str写入缓存buffer
}
    return b.String()
```

# 发生错误时使用defer关闭一个文件
* 如果你在一个for循环内部处理一系列文件，你需要使用defer确保文件在处理完毕后被关闭
* defer仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行

# 何时使用new()和make()
- 切片、映射和通道，使用make
- 数组、结构体和所有的值类型，使用new 

# 不需要将一个指向切片的指针传递给函数
* 切片实际是一个指向潜在数组的指针。
* func findBiggest( listOfNumbers []int ) int {}
* 当切片作为参数传递时，切记不要解引用切片。

# 使用指针指向接口类型
* 永远不要使用一个指针指向一个接口类型，因为它已经是一个指针

# 使用值类型时误用指针
* 将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。但是另一方面，值类型的内存是在栈上分配，内存分配快速且开销不大。

# 误用协程和通道
* 当且仅当代码中并发执行非常重要，才使用协程和通道。

# 闭包和协程的使用

# 糟糕的错误处理
* 不要使用布尔值  创建一个布尔型变量用于测试错误条件是多余的

# 避免错误检测使代码变得混乱
