# 错误处理与测试
* 不能执行抛异常操作
* 有一套 defer-panic-and-recover 机制（参见 13.2-13.3 节）
* Go 的设计者觉得 try/catch 机制的使用太泛滥了，而且从底层向更高的层级抛异常太耗费资源
* 通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 nil，则没有错误发生
* 产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil 就是发生了错误
* 为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误

# 错误处理
# 定义错误
* 任何时候当你需要一个新的错误类型，都可以用 errors（必须先 import）包的 errors.New 函数接收合适的错误信息来创建
* err := errors.New("math - square root of negative number")
* 通常（错误信息）都会有像 “Error:” 这样的前缀，所以你的错误信息不要以大写字母开头

# 用 fmt 创建错误对象
* 通常你想要返回包含错误参数的更有信息量的字符串，例如：可以用 fmt.Errorf() 来实现：它和 fmt.Printf() 完全一样，接收一个或多个格式占位符的格式化字符串和相应数量的占位变量

# 运行时异常和 panic
* 当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值
* 当发生错误必须中止程序时，panic 可以用于错误处理模式：
* if err != nil {
* 	panic("ERROR occurred:" + err.Error())
* }
* 在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者

# 从 panic 中恢复（Recover）
* 让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行
* recover 只能在 defer 修饰的函数（参见 6.4 节）中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 recover 会返回 nil，且没有其它效果
* panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止

# 自定义包中的错误处理和 panicking
* 在包内部，总是应该从 panic 中 recover：不允许显式的超出包范围的 panic()
* 向包的调用者返回错误值

# 一种用闭包处理错误的模式
* 这个模式只有当所有的函数都是同一种签名时可用，这样就有相当大的限制。一个很好的使用它的例子是 web 应用，所有的处理函数都是下面这样  func handler1(w http.ResponseWriter, r *http.Request) { ... }

# 启动外部命令和程序
* os 包有一个 StartProcess 函数可以调用或启动外部系统命令和二进制可执行文件
* 这个函数返回被启动进程的 id（pid），或者启动失败返回错误

# Go 中的单元测试和基准测试
* Go 的测试工具 gotest

# 测试的具体例子
* 正常的用例
* 反面的用例（错误的输入，如用负数或字母代替数字，没有输入等）
* 边界检查用例（如果参数的取值范围是 0 到 1000，检查 0 和 1000 的情况）

# 用（测试数据）表驱动测试

# 时间和内存消耗
* 可以用这个便捷脚本 xtime 来测量  
```
#!/bin/sh
/usr/bin/time -f '%Uu %Ss %er %MkB %C' "$@"
```

# 用 go test 调试
* 使用方式：go test -x -v -cpuprofile=prof.out -file x_test.go

# 用 pprof 调试
* 你可以在单机程序 progexec 中引入 runtime/pprof 包；这个包以 pprof 可视化工具需要的格式写入运行时报告数据