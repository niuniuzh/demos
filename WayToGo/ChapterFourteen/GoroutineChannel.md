# 协程（goroutine）与通道（channel）
* Go 原生支持应用之间的通信（网络，客户端和服务端，分布式计算，参见第 15 章）和程序的并发

# 什么是协程
* 一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存地址空间里的独立执行体
* 并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行的，也可以不是
* 不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。
* 在 Go 中，应用程序并发处理的部分被称作 goroutines（协程），它可以进行更有效的并发运算
* 协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的

# 并发和并行的差异
* 表达程序结构以便表示独立地执行的动作；所以Go的重点不在于并行的首要位置：并发程序可能是并行的，也可能不是
* 不论它启动了多少个协程；所以这些协程是并发运行的，但他们不是并行运行的：同一时间只有一个协程会处在运行状态

# 使用 GOMAXPROCS
* 必须设置 GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程

# 如何用命令行指定使用的核心数量
```
var numCores = flag.Int("n", 2, "number of CPU cores to use")
in main()
flag.Parse()
runtime.GOMAXPROCS(*numCores)
```
* 协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序

# Go 协程（goroutines）和协程（coroutines）
* Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的
* Go 协程通过通道来通信；协程通过让出和恢复操作来通信

# 协程间的信道
* Go 有一种特殊的类型，通道（channel），就像一个可以用于发送类型化数据的管道，由其负责协程之间的通信，从而避开所有由共享内存导致的陷阱
* 在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争
* 通道服务于通信的两个目的：值的交换，同步的，保证了两个计算（协程）任何时候都是可知状态
* 通道只能传输一种类型的数据，比如 chan int 或者 chan string，所有的类型都可以用于通道，空接口 interface{} 也可以
* 通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序

# 通信操作符 <-
* 这个操作符直观的标示了数据的传输：信息按照箭头的方向流动
* 操作符 <- 也被用来发送和接收，Go 尽管不必要，为了可读性，通道的命名通常以 ch 开头或者包含 chan
* 不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同

# 通道阻塞
* 默认情况下，通信是同步且无缓冲的:在有接受者接收数据之前，发送不会结束
* 必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者
* 所以通道的发送/接收操作在对方准备好之前是阻塞的：
* 对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）
* 对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。

# 通过一个（或多个）通道交换数据进行协程同步
* 通信是一种同步形式：通过通道，两个协程在通信（协程会和）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具
* 甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic，停止程序。
* 无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。

# 同步通道-使用带缓冲的通道
* 一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的 make 命令中设置它的容量
* 在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了

# 协程中用通道输出结果
* 为了知道计算何时完成，可以通过信道回报

# 信号量模式
* 协程通过在通道 ch 中放置一个值来处理结束的信号。main 协程等待 <-ch 直到从中获取到值

# 实现并行的 for 循环
* 在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。

# 用带缓冲通道实现一个信号量
* 带缓冲通道的容量和要同步的资源容量相同
* 通道的长度（当前存放的元素个数）与当前资源被使用的数量相同
* 容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）

# 给通道使用 for 循环
# 通道的方向
* 通道类型可以用注解来表示它只发送或者只接收：var send_only chan<- int  var recv_only <-chan int

# 协程的同步：关闭通道-测试阻塞的通道
* 只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。只有发送者需要关闭通道，接收者永远不会需要

# 使用 select 切换协程
* 从不同的并发执行的协程中获取值可以通过关键字select来完成
* 如果都阻塞了，会等待直到其中一个可以处理
* 如果多个可以处理，随机选择一个
* 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）
* select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出

# 通道、超时和计时器（Ticker）
* 习惯用法：简单超时模式
* 第二种形式：取消耗时很长的同步调用
* 第三种形式：假设程序从多个复制的数据库同时读取

# 协程和恢复（recover）
# 新旧模型对比：任务和worker
* 旧模式：使用共享内存进行同步
* 由各个任务组成的任务池共享内存；为了同步各个worker以及避免资源竞争，我们需要对任务池进行加锁保护：
* 新模式：使用通道
* 使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker在协程中启动，其数量N应该根据任务数量进行调整
* 使用锁的情景：访问共享数据结构中的缓存信息  保存应用程序上下文和状态信息数据
* 使用通道的情景：与异步操作的结果进行交互  分发任务  传递数据所有权

# 惰性生成器的实现
* 生成器是指当被调用时返回一个序列中下一个值的函数
* 生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值

# 实现 Futures 模式
* 有时候在你使用某一个值之前需要先对其进行计算
* Futures模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于Futures需要返回一个值
* 当开发一个计算密集型库时，使用Futures模式设计API接口是很有意义的。在你的包使用Futures模式，且能保持友好的API接口