# 结构（struct）与方法（method）
* Go 通过类型别名（alias types）和结构体的形式支持用户自定义类型，或者叫定制类型
* 组成结构体类型的那些数据称为 字段（fields）。每个字段都有一个类型和一个名字；在一个结构体中，字段名字必须是唯一的

# 结构体定义
```
type identifier struct {
    field1 type1
    field2 type2
    ...
}
```
* type T struct {a, b int} 也是合法的语法，它更适用于简单的结构体
* 结构体的字段可以是任何类型，甚至是结构体本身（参考第 10.5 节），也可以是函数或者接口（参考第 11 章）
* 使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)
* 可以直接通过指针，像 pers2.lastName="Woodward" 这样给结构体字段赋值，没有像 C++ 中那样需要使用 -> 操作符，Go 会自动做这样的转换

# 结构体的内存布局
* Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体

# 递归结构体
* 结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）

# 结构体转换
* 当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型,需要注意其中非法赋值或转换引起的编译错误

# 结构体工厂
* Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂”方法
```
type File struct {
    fd      int     // 文件描述符
    name    string  // 文件名
}
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }

    return &File{fd, name}
}
```
* 然后这样调用它：f := NewFile(10, "./test.txt")

# 如何强制使用工厂方法
* 通过应用可见性规则参考4.2.1节、9.5 节就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样

# map 和 struct vs new() 和 make()
* 试图 make() 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 new() 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 new(Foo) 返回的是一个指向 nil 的指针，它尚未被分配内存。所以在使用 map 时要特别谨慎

# 使用自定义包中的结构体
# 带标签的结构体
* 结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）
* 它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它
* reflect.TypeOf() 可以获取变量的正确类型
* 如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性

# 匿名字段和内嵌结构体
* 结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字
* 匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体
* Go 语言中的继承是通过内嵌或组合来实现的

# 内嵌结构体
* 结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用

# 命名冲突
* 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式
* 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误(不使用没关系)

# 方法
* Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数
* 任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型
* 一个类型加上它的方法等价于面向对象中的一个类
* 类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的
* 定义方法的一般格式如下：func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... }

# 函数和方法的区别
* 函数将变量作为参数：Function1(recv)
* 方法在变量上被调用：recv.Method1()
* 不要忘记 Method1 后边的括号 ()，否则会引发编译器错误
* 接收者必须有一个显式的名字，这个名字必须在方法中被使用
* receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明
* 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的
