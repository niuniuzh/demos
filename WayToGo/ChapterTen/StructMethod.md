# 结构（struct）与方法（method）
* Go 通过类型别名（alias types）和结构体的形式支持用户自定义类型，或者叫定制类型
* 组成结构体类型的那些数据称为 字段（fields）。每个字段都有一个类型和一个名字；在一个结构体中，字段名字必须是唯一的

# 结构体定义
```
type identifier struct {
    field1 type1
    field2 type2
    ...
}
```
* type T struct {a, b int} 也是合法的语法，它更适用于简单的结构体
* 结构体的字段可以是任何类型，甚至是结构体本身（参考第 10.5 节），也可以是函数或者接口（参考第 11 章）
* 使用 new 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：var t *T = new(T)
* 可以直接通过指针，像 pers2.lastName="Woodward" 这样给结构体字段赋值，没有像 C++ 中那样需要使用 -> 操作符，Go 会自动做这样的转换

# 结构体的内存布局
* Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体

# 递归结构体
* 结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）

# 结构体转换
* 当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型,需要注意其中非法赋值或转换引起的编译错误

# 结构体工厂
* Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂”方法
```
type File struct {
    fd      int     // 文件描述符
    name    string  // 文件名
}
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }

    return &File{fd, name}
}
```
* 然后这样调用它：f := NewFile(10, "./test.txt")

# 如何强制使用工厂方法
* 通过应用可见性规则参考4.2.1节、9.5 节就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样

# map 和 struct vs new() 和 make()
* 试图 make() 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 new() 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 new(Foo) 返回的是一个指向 nil 的指针，它尚未被分配内存。所以在使用 map 时要特别谨慎

# 使用自定义包中的结构体
# 带标签的结构体
* 结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）
* 它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它
* reflect.TypeOf() 可以获取变量的正确类型
* 如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性

# 匿名字段和内嵌结构体
* 结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字
* 匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体
* Go 语言中的继承是通过内嵌或组合来实现的

# 内嵌结构体
* 结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用

# 命名冲突
* 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式
* 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误(不使用没关系)

# 方法
* Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数
* 任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型
* 一个类型加上它的方法等价于面向对象中的一个类
* 类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的
* 定义方法的一般格式如下：func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... }

# 函数和方法的区别
* 函数将变量作为参数：Function1(recv)
* 方法在变量上被调用：recv.Method1()
* 不要忘记 Method1 后边的括号 ()，否则会引发编译器错误
* 接收者必须有一个显式的名字，这个名字必须在方法中被使用
* receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明
* 方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的

# 指针或值作为接收者
* 指针方法和值方法都可以在指针或非指针上被调用

# 方法和未导出字段
* 类型 Person 被明确的导出了，但是它的字段没有被导出
* 提供 getter 和 setter 方法。对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名
```
package person

type Person struct {
	firstName string
	lastName  string
}

func (p *Person) FirstName() string {
	return p.firstName
}

func (p *Person) SetFirstName(newName string) {
	p.firstName = newName
}
package main

import (
	"./person"
	"fmt"
)

func main() {
	p := new(person.Person)
	// p.firstName undefined
	// (cannot refer to unexported field or method firstName)
	// p.firstName = "Eric"
	p.SetFirstName("Eric")
	fmt.Println(p.FirstName()) // Output: Eric
}
```
* 并发访问对象
* 对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 sync（参考第 9.3 节）中的方法

# 内嵌类型的方法和继承
* 当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法：将父类型放在子类型中来实现亚型
* 内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法

# 如何在类型中嵌入功能
* 有两种方法来实现在类型中嵌入功能
* 聚合（或组合）：包含一个所需功能类型的具名字段
* 内嵌：内嵌（匿名地）所需功能类型

# 多重继承
* 多重继承指的是类型获得多个父类型行为的能力，
* 在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承

# 通用方法和方法命名
* 在编程中一些基本操作会一遍又一遍的出现，比如打开（Open）、关闭（Close）、读（Read）、写（Write）、排序（Sort）等等

# 和其他面向对象语言比较 Go 的类型和方法
* 如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系
* 在 Go 中，类型就是类（数据和关联的方法）继承有两个好处：代码复用和多态
* 在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 组件编程

# 类型的 String() 方法和格式化描述符
* 类型定义了 String() 方法，它会被用在 fmt.Printf() 中生成默认的输出
* 等同于使用格式化描述符 %v 产生的输出。还有 fmt.Print() 和 fmt.Println() 也会自动使用 String() 方法
* 格式化描述符 %T 会给出类型的完全规格，%#v 会给出实例的完整输出，包括它的字段
* 不要在 String() 方法里面调用涉及 String() 方法的方法，它会导致意料之外的错误

# 垃圾回收和 SetFinalizer
* 在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存
* 通过调用 runtime.GC() 函数可以显式的触发 GC
* 想知道当前的内存状态，可以使用：
```
var m runtime.MemStats
runtime.ReadMemStats(&m)
fmt.Printf("%d Kb\n", m.Alloc / 1024)
```